{"ast":null,"code":"import { cards } from \"../cards\";\nimport findIndex from \"lodash.findindex\";\nimport isEqual from \"lodash.isequal\";\nconst randNum = () => Math.ceil(81 * Math.random());\nexport const initDeck = () => {\n  let newDeck = [];\n  while (newDeck.length < 12) {\n    const newNum = randNum();\n    if (!newDeck.includes(newNum)) {\n      newDeck.push(newNum);\n    }\n  }\n  return newDeck.map(number => {\n    const newCard = cards[number - 1];\n    return newCard;\n  });\n};\nconst isCardInDeck = (deck, cardId) => {\n  return findIndex(deck, {\n    id: cardId\n  }) === -1 ? false : true;\n};\nexport let deck = initDeck();\nexport const newCard = existingDeck => {\n  let newCard = 0;\n  while (newCard !== 0) {\n    const newNum = randNum();\n    if (!existingDeck.includes(newNum)) {\n      newCard = newNum;\n    }\n  }\n  return newCard;\n};\nexport const checkSet = selectedCards => {\n  let card1 = selectedCards[0];\n  let card2 = selectedCards[1];\n  let card3 = selectedCards[2];\n  if (\n  //all colors are the same\n  (isEqual(card1.color, card2.color) && isEqual(card1.color, card3.color) ||\n  //or all colors are different\n  !isEqual(card1.color, card2.color) && !isEqual(card2.color, card3.color) && !isEqual(card1.color, card3.color)) && (\n  //all shapes are the same\n  isEqual(card1.shape, card2.shape) && isEqual(card1.shape, card3.shape) ||\n  //or all shapes are different\n  !isEqual(card1.shape, card2.shape) && !isEqual(card2.shape, card3.shape) && !isEqual(card1.shape, card3.shape)) && (\n  //all fills are the same\n  isEqual(card1.fill, card2.fill) && isEqual(card1.fill, card3.fill) ||\n  //or all fills are different\n  !isEqual(card1.fill, card2.fill) && !isEqual(card2.fill, card3.fill) && !isEqual(card1.fill, card3.fill)) && (\n  //all quantities are the same\n  isEqual(card1.quantity, card2.quantity) && isEqual(card2.quantity, card3.quantity) ||\n  //or all quantities are different\n  !isEqual(card1.quantity, card2.quantity) && !isEqual(card2.quantity, card3.quantity) && !isEqual(card1.quantity, card3.quantity))) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * If the 3 selected cards are a set, updateDeck removes those cards\n * and adds 3 new random cards not currently in the deck\n */\nexport const updateDeck = deck => {\n  const selectedCards = deck.filter(card => card.selected === true);\n  let newCardIds = [];\n  let newDeck = [...deck];\n  selectedCards.forEach(card => {\n    const selectedCardIdx = findIndex(newDeck, {\n      id: card.id\n    });\n    let newCard = undefined;\n    while (newCard === undefined) {\n      let newIdx = randNum();\n      if (!isCardInDeck(deck, newIdx) && !newCardIds.includes(newIdx)) {\n        newCardIds.push(newIdx);\n        newCard = cards[newIdx - 1];\n        newDeck[selectedCardIdx] = newCard;\n      }\n    }\n  });\n  deck.forEach(card => card.selected = false);\n  return newDeck;\n};","map":{"version":3,"names":["cards","findIndex","isEqual","randNum","Math","ceil","random","initDeck","newDeck","length","newNum","includes","push","map","number","newCard","isCardInDeck","deck","cardId","id","existingDeck","checkSet","selectedCards","card1","card2","card3","color","shape","fill","quantity","updateDeck","filter","card","selected","newCardIds","forEach","selectedCardIdx","undefined","newIdx"],"sources":["/Users/cd/Documents/Projects/set-game2/src/utils/utils.ts"],"sourcesContent":["import { cards } from \"../cards\";\nimport { CardType } from \"../types/CardType\";\nimport findIndex from \"lodash.findindex\";\nimport isEqual from \"lodash.isequal\";\n\nconst randNum = () => Math.ceil(81 * Math.random());\n\nexport const initDeck = () => {\n  let newDeck: number[] = [];\n\n  while (newDeck.length < 12) {\n    const newNum = randNum();\n\n    if (!newDeck.includes(newNum)) {\n      newDeck.push(newNum);\n    }\n  }\n  return newDeck.map((number) => {\n    const newCard = cards[number - 1];\n    return newCard;\n  });\n};\n\nconst isCardInDeck = (deck: CardType[], cardId: number) => {\n  return findIndex(deck, { id: cardId }) === -1 ? false : true;\n};\n\nexport let deck = initDeck();\n\nexport const newCard = (existingDeck: number[]) => {\n  let newCard: number = 0;\n\n  while (newCard !== 0) {\n    const newNum = randNum();\n    if (!existingDeck.includes(newNum)) {\n      newCard = newNum;\n    }\n  }\n  return newCard;\n};\n\nexport const checkSet = (selectedCards: CardType[]) => {\n  let card1 = selectedCards[0];\n  let card2 = selectedCards[1];\n  let card3 = selectedCards[2];\n\n  if (\n    //all colors are the same\n    ((isEqual(card1.color, card2.color) && isEqual(card1.color, card3.color)) ||\n      //or all colors are different\n      (!isEqual(card1.color, card2.color) &&\n        !isEqual(card2.color, card3.color) &&\n        !isEqual(card1.color, card3.color))) &&\n    //all shapes are the same\n    ((isEqual(card1.shape, card2.shape) && isEqual(card1.shape, card3.shape)) ||\n      //or all shapes are different\n      (!isEqual(card1.shape, card2.shape) &&\n        !isEqual(card2.shape, card3.shape) &&\n        !isEqual(card1.shape, card3.shape))) &&\n    //all fills are the same\n    ((isEqual(card1.fill, card2.fill) && isEqual(card1.fill, card3.fill)) ||\n      //or all fills are different\n      (!isEqual(card1.fill, card2.fill) &&\n        !isEqual(card2.fill, card3.fill) &&\n        !isEqual(card1.fill, card3.fill))) &&\n    //all quantities are the same\n    ((isEqual(card1.quantity, card2.quantity) &&\n      isEqual(card2.quantity, card3.quantity)) ||\n      //or all quantities are different\n      (!isEqual(card1.quantity, card2.quantity) &&\n        !isEqual(card2.quantity, card3.quantity) &&\n        !isEqual(card1.quantity, card3.quantity)))\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * If the 3 selected cards are a set, updateDeck removes those cards\n * and adds 3 new random cards not currently in the deck\n */\nexport const updateDeck = (deck: CardType[]) => {\n  const selectedCards = deck.filter((card) => card.selected === true);\n\n  let newCardIds: number[] = [];\n  let newDeck = [...deck];\n  selectedCards.forEach((card) => {\n    const selectedCardIdx: number = findIndex(newDeck, { id: card.id });\n\n    let newCard = undefined;\n\n    while (newCard === undefined) {\n      let newIdx = randNum();\n\n      if (!isCardInDeck(deck, newIdx) && !newCardIds.includes(newIdx)) {\n        newCardIds.push(newIdx);\n        newCard = cards[newIdx - 1];\n        newDeck[selectedCardIdx] = newCard;\n      }\n    }\n  });\n  deck.forEach((card) => (card.selected = false));\n  return newDeck;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { cards } from \"../cards\";\nconst randNum = () => Math.ceil(12 * Math.random());\nconst randCard = () => {\n  const randIdx = randNum();\n  return cards[randIdx];\n};\nexport const initDeck = () => {\n  let newDeck = [];\n  while (newDeck.length < 12) {\n    const newNum = randNum();\n    console.log(\"newNum\", newNum);\n    if (!newDeck.includes(newNum)) {\n      newDeck.push(newNum);\n    }\n  }\n  console.log(\"newDeck\", newDeck);\n  return newDeck.map(number => {\n    console.log(\"number!!\", number);\n    const newCard = cards[number + 1];\n    console.log(\"newCard\", newCard);\n    return newCard;\n  });\n};\nexport let deck = initDeck();\nexport const newCard = existingDeck => {\n  let newCard = 0;\n  while (newCard !== 0) {\n    const newNum = randNum();\n    if (!existingDeck.includes(newNum)) {\n      newCard = newNum;\n    }\n  }\n  return newCard;\n};\nexport const checkSet = selectedCards => {\n  /* hash = {\n    1 => [one, red, peanut, solid]\n    2 => [two, red, peanut, solid]\n    3 => [three, red, peanut, solid]\n  }\n     hash.get(card)\n   */\n  console.log(\"CHECKED!\");\n  return true;\n};\n\n/**\n *\n * If the 3 selected cards are a set, updateDeck removes those cards\n * and adds 3 new random cards not currently in the deck\n */\nexport const updateDeck = (deck, selectedCards) => {\n  selectedCards.forEach(selectedCard => {\n    const selectedCardId = selectedCard.id;\n    const idxInDeck = deck.filter(card => card.id === selectedCardId)[0].id;\n    let newCard = undefined;\n    while (newCard === undefined) {\n      let newIdx = randNum();\n      if (!deck.some(deckCard => deckCard.id === newIdx)) {\n        newCard = cards[newIdx];\n        deck[idxInDeck] = newCard;\n      }\n    }\n  });\n  return deck;\n};","map":{"version":3,"names":["cards","randNum","Math","ceil","random","randCard","randIdx","initDeck","newDeck","length","newNum","console","log","includes","push","map","number","newCard","deck","existingDeck","checkSet","selectedCards","updateDeck","forEach","selectedCard","selectedCardId","id","idxInDeck","filter","card","undefined","newIdx","some","deckCard"],"sources":["/Users/cd/Documents/Projects/set-game2/src/utils/Deck.ts"],"sourcesContent":["import { cards } from \"../cards\";\nimport { Card } from \"../types/Card\";\n\nconst randNum = () => Math.ceil(12 * Math.random());\n\nconst randCard = () => {\n  const randIdx = randNum();\n  return cards[randIdx];\n};\n\nexport const initDeck = () => {\n  let newDeck: number[] = [];\n\n  while (newDeck.length < 12) {\n    const newNum = randNum();\n\n    console.log(\"newNum\", newNum);\n\n    if (!newDeck.includes(newNum)) {\n      newDeck.push(newNum);\n    }\n  }\n  console.log(\"newDeck\", newDeck);\n  return newDeck.map((number) => {\n    console.log(\"number!!\", number);\n    const newCard = cards[number + 1];\n    console.log(\"newCard\", newCard);\n    return newCard;\n  });\n};\n\nexport let deck = initDeck();\n\nexport const newCard = (existingDeck: number[]) => {\n  let newCard: number = 0;\n\n  while (newCard !== 0) {\n    const newNum = randNum();\n    if (!existingDeck.includes(newNum)) {\n      newCard = newNum;\n    }\n  }\n  return newCard;\n};\n\nexport const checkSet = (selectedCards: Card[]) => {\n  /* hash = {\n    1 => [one, red, peanut, solid]\n    2 => [two, red, peanut, solid]\n    3 => [three, red, peanut, solid]\n  }\n\n    hash.get(card)\n\n  */\n  console.log(\"CHECKED!\");\n  return true;\n};\n\n/**\n *\n * If the 3 selected cards are a set, updateDeck removes those cards\n * and adds 3 new random cards not currently in the deck\n */\nexport const updateDeck = (deck: Card[], selectedCards: Card[]) => {\n  selectedCards.forEach((selectedCard) => {\n    const selectedCardId = selectedCard.id;\n\n    const idxInDeck = deck.filter((card) => card.id === selectedCardId)[0].id;\n\n    let newCard = undefined;\n\n    while (newCard === undefined) {\n      let newIdx = randNum();\n\n      if (!deck.some((deckCard) => deckCard.id === newIdx)) {\n        newCard = cards[newIdx];\n        deck[idxInDeck] = newCard;\n      }\n    }\n  });\n  return deck;\n};\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,UAAU;AAGhC,MAAMC,OAAO,GAAGA,CAAA,KAAMC,IAAI,CAACC,IAAI,CAAC,EAAE,GAAGD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC;AAEnD,MAAMC,QAAQ,GAAGA,CAAA,KAAM;EACrB,MAAMC,OAAO,GAAGL,OAAO,CAAC,CAAC;EACzB,OAAOD,KAAK,CAACM,OAAO,CAAC;AACvB,CAAC;AAED,OAAO,MAAMC,QAAQ,GAAGA,CAAA,KAAM;EAC5B,IAAIC,OAAiB,GAAG,EAAE;EAE1B,OAAOA,OAAO,CAACC,MAAM,GAAG,EAAE,EAAE;IAC1B,MAAMC,MAAM,GAAGT,OAAO,CAAC,CAAC;IAExBU,OAAO,CAACC,GAAG,CAAC,QAAQ,EAAEF,MAAM,CAAC;IAE7B,IAAI,CAACF,OAAO,CAACK,QAAQ,CAACH,MAAM,CAAC,EAAE;MAC7BF,OAAO,CAACM,IAAI,CAACJ,MAAM,CAAC;IACtB;EACF;EACAC,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEJ,OAAO,CAAC;EAC/B,OAAOA,OAAO,CAACO,GAAG,CAAEC,MAAM,IAAK;IAC7BL,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEI,MAAM,CAAC;IAC/B,MAAMC,OAAO,GAAGjB,KAAK,CAACgB,MAAM,GAAG,CAAC,CAAC;IACjCL,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEK,OAAO,CAAC;IAC/B,OAAOA,OAAO;EAChB,CAAC,CAAC;AACJ,CAAC;AAED,OAAO,IAAIC,IAAI,GAAGX,QAAQ,CAAC,CAAC;AAE5B,OAAO,MAAMU,OAAO,GAAIE,YAAsB,IAAK;EACjD,IAAIF,OAAe,GAAG,CAAC;EAEvB,OAAOA,OAAO,KAAK,CAAC,EAAE;IACpB,MAAMP,MAAM,GAAGT,OAAO,CAAC,CAAC;IACxB,IAAI,CAACkB,YAAY,CAACN,QAAQ,CAACH,MAAM,CAAC,EAAE;MAClCO,OAAO,GAAGP,MAAM;IAClB;EACF;EACA,OAAOO,OAAO;AAChB,CAAC;AAED,OAAO,MAAMG,QAAQ,GAAIC,aAAqB,IAAK;EACjD;AACF;AACA;AACA;AACA;AACA;AACA;EAGEV,OAAO,CAACC,GAAG,CAAC,UAAU,CAAC;EACvB,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMU,UAAU,GAAGA,CAACJ,IAAY,EAAEG,aAAqB,KAAK;EACjEA,aAAa,CAACE,OAAO,CAAEC,YAAY,IAAK;IACtC,MAAMC,cAAc,GAAGD,YAAY,CAACE,EAAE;IAEtC,MAAMC,SAAS,GAAGT,IAAI,CAACU,MAAM,CAAEC,IAAI,IAAKA,IAAI,CAACH,EAAE,KAAKD,cAAc,CAAC,CAAC,CAAC,CAAC,CAACC,EAAE;IAEzE,IAAIT,OAAO,GAAGa,SAAS;IAEvB,OAAOb,OAAO,KAAKa,SAAS,EAAE;MAC5B,IAAIC,MAAM,GAAG9B,OAAO,CAAC,CAAC;MAEtB,IAAI,CAACiB,IAAI,CAACc,IAAI,CAAEC,QAAQ,IAAKA,QAAQ,CAACP,EAAE,KAAKK,MAAM,CAAC,EAAE;QACpDd,OAAO,GAAGjB,KAAK,CAAC+B,MAAM,CAAC;QACvBb,IAAI,CAACS,SAAS,CAAC,GAAGV,OAAO;MAC3B;IACF;EACF,CAAC,CAAC;EACF,OAAOC,IAAI;AACb,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}